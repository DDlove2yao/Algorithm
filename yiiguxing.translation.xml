<application>
  <component name="AppStorage">
    <histories>
      <item value="Interface to be implemented by beans that want to be aware of their * bean name in a bean factory. Note that it is not usually recommended * that an object depends on its bean name, as this represents a potentially * brittle dependence on external configuration, as well as a possibly * unnecessary dependence on a Spring API." />
      <item value="nterface to be implemented by beans that want to be aware of their * bean name in a bean factory. Note that it is not usually recommended * that an object depends on its bean name, as this represents a potentially * brittle dependence on external configuration, as well as a possibly * unnecessary dependence on a Spring API." />
      <item value="A marker superinterface indicating that a bean is eligible to be notified by the * Spring container of a particular framework object through a callback-style method. * The actual method signature is determined by individual subinterfaces but should * typically consist of just one void-returning method that accepts a single argument." />
      <item value="get Aliases" />
      <item value="hierarchical" />
      <item value="canonical bean name" />
      <item value="canonical" />
      <item value="alias" />
      <item value="retrieve" />
      <item value="Return an instance, which may be shared or independent, of the specified bean. * &lt;p&gt;This method allows a Spring BeanFactory to be used as a replacement for the * Singleton or Prototype design pattern. Callers may retain references to * returned objects in the case of Singleton beans. * &lt;p&gt;Translates aliases back to the corresponding canonical bean name. * Will ask the parent factory if the bean cannot be found in this factory instance. * @param name the name of the bean to retrieve * @return an instance of the bean * @throws NoSuchBeanDefinitionException if there is no bean with the specified name * @throws BeansException if the bean could not be obtained" />
      <item value="Used to dereference a {@link FactoryBean} instance and distinguish it from * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named * {@code myJndiObject} is a FactoryBean, getting {@code &amp;myJndiObject} * will return the factory, not the instance returned by the factory." />
      <item value="PREFIX" />
      <item value="On shutdown of a bean factory, the following lifecycle methods apply" />
      <item value="only applicable when running in an application context" />
      <item value="Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is:" />
      <item value="In contrast to the methods in {@link ListableBeanFactory}, all of the * operations in this interface will also check parent factories if this is a * {@link HierarchicalBeanFactory}. If a bean is not found in this factory instance, * the immediate parent factory will be asked. Beans in this factory instance * are supposed to override beans of the same name in any parent factory." />
      <item value="Normally a BeanFactory will load bean definitions stored in a configuration * source (such as an XML document), and use the {@code org.springframework.beans} * package to configure the beans. However, an implementation could simply return * Java objects it creates as necessary directly in Java code. There are no * constraints on how the definitions could be stored: LDAP, RDBMS, XML, * properties file, etc. Implementations are encouraged to support references * amongst beans (Dependency Injection)." />
      <item value="Note that it is generally better to rely on Dependency Injection * (&quot;push&quot; configuration) to configure application objects through setters * or constructors, rather than use any form of &quot;pull&quot; configuration like a * BeanFactory lookup. Spring's Dependency Injection functionality is * implemented using this BeanFactory interface and its subinterfaces." />
      <item value="This interface is implemented by objects that hold a number of bean definitions, * each uniquely identified by a String name. Depending on the bean definition, * the factory will return either an independent instance of a contained object * (the Prototype design pattern), or a single shared instance (a superior * alternative to the Singleton design pattern, in which the instance is a * singleton in the scope of the factory). Which type of instance will be returned * depends on the bean factory configuration: the API is the same. Since Spring * 2.0, further scopes are available depending on the concrete application * context (e.g. &quot;request&quot; and &quot;session&quot; scopes in a web environment)." />
      <item value="This is the basic client view of a bean container" />
      <item value="If the &quot;singleton&quot; flag is {@code true} (the default), * this class will create the object that it creates exactly once * on initialization and subsequently return said singleton instance * on all calls to the {@link #getObject()} method." />
      <item value="non Synthetic Constructors" />
      <item value="lookup Methods Checked" />
      <item value="injection Metadata Cache" />
      <item value="Set the 'autowired' annotation type, to be used on constructors, fields, * setter methods, and arbitrary config methods. * &lt;p&gt;The default autowired annotation types are the Spring-provided * {@link Autowired @Autowired} and {@link Value @Value} annotations as well * as JSR-330's {@link javax.inject.Inject @Inject} annotation, if available. * &lt;p&gt;This setter property exists so that developers can provide their own * (non-Spring-specific) annotation type to indicate that a member is supposed * to be autowired." />
      <item value="Autowired Annotation Bean Post Processor" />
      <item value="rg.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor} * implementation that autowires annotated fields, setter methods, and arbitrary * config methods. Such members to be injected are detected through annotations: * by default, Spring's {@link Autowired @Autowired} and {@link Value @Value} * annotations." />
      <item value="Declares whether the annotated dependency is required." />
      <item value="Bean property setter methods are effectively just a special case of such a general * config method." />
      <item value="Config methods may have an arbitrary name and any number of arguments" />
      <item value="Fields are injected right after construction of a bean, before any config methods * are invoked. Such a config field does not have to be public" />
      <item value="nly one constructor of any given bean class may declare this annotation with the * {@link #required} attribute set to {@code true}, indicating &lt;i&gt;the&lt;/i&gt; constructor * to autowire when used as a Spring bean. Furthermore, if the {@code required} * attribute is set to {@code true}, only a single constructor may be annotated * with {@code @Autowired}. If multiple &lt;i&gt;non-required&lt;/i&gt; constructors declare the * annotation, they will be considered as candidates for autowiring. The constructor * with the greatest number of dependencies that can be satisfied by matching beans * in the Spring container will be chosen. If none of the candidates can be satisfied, * then a primary/default constructor (if present) will be used. If a class only * declares a single constructor to begin with, it will always be used, even if not * annotated. An annotated constructor does not have to be public." />
      <item value="Only one constructor of any given bean class may declare this annotation with the * {@link #required} attribute set to {@code true}, indicating &lt;i&gt;the&lt;/i&gt; constructor * to autowire when used as a Spring bean. Furthermore, if the {@code required} * attribute is set to {@code true}, only a single constructor may be annotated * with {@code @Autowired}. If multiple &lt;i&gt;non-required&lt;/i&gt; constructors declare the * annotation, they will be considered as candidates for autowiring. The constructor * with the greatest number of dependencies that can be satisfied by matching beans * in the Spring container will be chosen. If none of the candidates can be satisfied, * then a primary/default constructor (if present) will be used. If a class only * declares a single constructor to begin with, it will always be used, even if not * annotated. An annotated constructor does not have to be public." />
      <item value="arks a constructor, field, setter method, or config method as to be autowired by * Spring's dependency injection facilities. This is an alternative to the JSR-330 * {@link javax.inject.Inject} annotation, adding required-vs-optional semantics. * * &lt;h3&gt;Autowired Constructors&lt;/h3&gt; * &lt;p&gt;Only one constructor of any given bean class may declare this annotation with the * {@link #required} attribute set to {@code true}, indicating &lt;i&gt;the&lt;/i&gt; constructor * to autowire when used as a Spring bean. Furthermore, if the {@code required} * attribute is set to {@code true}, only a single constructor may be annotated * with {@code @Autowired}. If multiple &lt;i&gt;non-required&lt;/i&gt; constructors declare the * annotation, they will be considered as candidates for autowiring. The constructor * with the greatest number of dependencies that can be satisfied by matching beans * in the Spring container will be chosen. If none of the candidates can be satisfied, * then a primary/default constructor (if present) will be used. If a class only * declares a single constructor to begin with, it will always be used, even if not * annotated. An annotated constructor does not have to be public." />
      <item value="Obtain the annotation metadata (as well as basic class metadata) * for this bean definition's bean class. * @return the annotation metadata object (never {@code null})" />
      <item value="The largest possible table capacity. This value must be * exactly 1&lt;&lt;30 to stay within Java array allocation and indexing * bounds for power of two table sizes, and is further required * because the top two bits of 32bit hash fields are used for * control purposes. */" />
      <item value="ConcurrentHashMaps support a set of sequential and parallel bulk * operations that, unlike most {@link Stream} methods, are designed * to be safely, and often sensibly, applied even with maps that are * being concurrently updated by other threads; for example, when * computing a snapshot summary of the values in a shared registry. * There are three kinds of operation, each with four forms, accepting * functions with keys, values, entries, and (key, value) pairs as * arguments and/or return values. Because the elements of a * ConcurrentHashMap are not ordered in any particular way, and may be * processed in different orders in different parallel executions, the * correctness of supplied functions should not depend on any * ordering, or on any other objects or values that may transiently * change while computation is in progress; and except for forEach * actions, should ideally be side-effect-free. Bulk operations on * {@link Map.Entry} objects do not support method {@code setValue}." />
      <item value="Retrieval operations (including {@code get}) generally do not * block, so may overlap with update operations (including {@code put} * and {@code remove}). Retrievals reflect the results of the most * recently &lt;em&gt;completed&lt;/em&gt; update operations holding upon their * onset. (More formally, an update operation for a given key bears a * &lt;em&gt;happens-before&lt;/em&gt; relation with any (non-null) retrieval for * that key reporting the updated value.) For aggregate operations * such as {@code putAll} and {@code clear}, concurrent retrievals may * reflect insertion or removal of only some entries. Similarly, * Iterators, Spliterators and Enumerations return elements reflecting the * state of the hash table at some point at or since the creation of the * iterator/enumeration. They do &lt;em&gt;not&lt;/em&gt; throw {@link * java.util.ConcurrentModificationException ConcurrentModificationException}. * However, iterators are designed to be used by only one thread at a time. * Bear in mind that the results of aggregate status methods including * {@code size}, {@code isEmpty}, and {@code containsValue} are typically * useful only when a map is not undergoing concurrent updates in other threads. * Otherwise the results of these methods reflect transient states * that may be adequate for monitoring or estimation purposes, but not * for program control." />
      <item value="A hash table supporting full concurrency of retrievals and * high expected concurrency for updates. This class obeys the * same functional specification as {@link java.util.Hashtable}, and * includes versions of methods corresponding to each method of * {@code Hashtable}. However, even though all operations are * thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking, * and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table * in a way that prevents all access. This class is fully * interoperable with {@code Hashtable} in programs that rely on its * thread safety but not on its synchronization details." />
      <item value="Currency" />
      <item value="is Primitive" />
      <item value="@implNote The sorting algorithm is a parallel sort-merge that breaks the * array into sub-arrays that are themselves sorted and then merged. When * the sub-array length reaches a minimum granularity, the sub-array is * sorted using the appropriate {@link Arrays#sort(byte[]) Arrays.sort} * method. If the length of the specified array is less than the minimum * granularity, then it is sorted using the appropriate {@link * Arrays#sort(byte[]) Arrays.sort} method. The algorithm requires a * working space no greater than the size of the original array. The * {@link ForkJoinPool#commonPool() ForkJoin common pool} is used to * execute any parallel tasks." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="41" />
        <entry key="ENGLISH" value="42" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>